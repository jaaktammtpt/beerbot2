from fastapi import FastAPI, Request, HTTPException
from pydantic import BaseModel, Field
from typing import Dict, List, Optional, Any

app = FastAPI()

# 1. Optimeeritud Q-väärtused (nädala varu eesmärk)
# Need väärtused on leitud numbriliste simulatsioonidega, et olla robustsed
# erinevate nõudluste ja täitmisaegadega stsenaariumite korral [6, 12, 13].
# Need on näited Robust Analysis of Order Policy Generated by Smoothed Q-model 
# allikatest [12, 14]. Näiteks: Jaemüüja (Retailer) 1, Hulgimüüja (Wholesaler) 3.25, Turustaja (Distributor) 4, Tehas (Factory) 4.
Q_OPTIMIZED = {
    "retailer": 1.0,      
    "wholesaler": 3.25, 
    "distributor": 4.0,   
    "factory": 4.0        
}

# 2. Andmemudelite määratlemine Pydanticu abil (vastavalt BeerBot API spetsifikatsioonile) [1, 11]

class RoleState(BaseModel):
    inventory: int = Field(..., ge=0)
    backlog: int = Field(..., ge=0)
    incoming_orders: int = Field(..., ge=0)
    arriving_shipments: int = Field(..., ge=0)

class WeekData(BaseModel):
    week: int
    roles: Dict[str, RoleState]
    orders: Dict[str, int]

class WeeklyStepRequest(BaseModel):
    mode: str
    week: int
    weeks_total: int
    seed: int
    weeks: List[WeekData]

class HandshakeRequest(BaseModel):
    handshake: bool
    ping: str
    seed: int

class RequestBody(BaseModel):
    handshake: Optional[bool] = False
    ping: Optional[str] = None
    seed: Optional[int] = None
    mode: Optional[str] = None
    week: Optional[int] = None
    weeks_total: Optional[int] = None
    weeks: Optional[List[WeekData]] = None


# 3. Tellimuspoliitika loogika (Order-Up-To Q-mudeli alusel)

def calculate_order(role_name: str, current_state: RoleState, history: List[WeekData]) -> int:
    """
    Arvutab tellimuse detsentraliseeritud BlackBox režiimis [4].
    Varude sihttase (TSL) = Q_X * Oodatav Nõudlus.
    Tellimus = TSL - Varude Positsioon.
    """
    
    inventory = current_state.inventory
    backlog = current_state.backlog
    incoming_orders = current_state.incoming_orders
    
    # Varude positsioon (Inventory Position - IP)
    # Lihtsustatud IP, eeldades, et trassil olevad saadetised (pipeline) 
    # on ebatäielikult teada BlackBox režiimis, ning keskendume varude ja backlogs'i vahele.
    # NB: Täpne Q-mudel kasutab ka trassil olevaid tellimusi [15, 16], 
    # kuid BeerBoti spetsifikatsioon 'arriving_shipments' on see, mis jõuab KOHALE sel nädalal [5].
    inventory_position = inventory - backlog
    
    # Nõudluse prognoos (lihtsustatud lähendus BlackBox jaoks)
    # Prognoosime nõudlust viimase nädala sissetulevate tellimuste põhjal [17, 18].
    demand_forecast = incoming_orders
    
    # Määra Q-väärtus (mitu nädalat varu hoida)
    Q_value = Q_OPTIMIZED.get(role_name, 1.0)
    
    # Varude sihttase (Target Stock Level - TSL)
    target_stock_level = int(Q_value * demand_forecast)

    # Arvuta Tellimuse Kogus (Order Quantity)
    # Tellimus = TSL - Inventory Position
    order_quantity = target_stock_level - inventory_position
    
    # Tellimus peab olema mittemidagi negatiivne täisarv [19]
    final_order = max(0, order_quantity)
    
    return final_order

# 4. FastAPI endpoint /api/decision

@app.post("/api/decision")
async def handle_decision(data: RequestBody):
    
    # Käepigistuse (Handshake) käsitlus [3]
    if data.handshake:
        if data.ping != "hello" or data.seed is None:
             raise HTTPException(status_code=400, detail="Invalid handshake request")

        return {
            "ok": True,
            "student_email": "jaakta@taltech.ee", # ASENDA OMA E-POSTIGA
            "algorithm_name": "FastAPI_SmoothedQModel",
            "version": "v1.2.0",
            "supports": {"blackbox": True, "glassbox": False},
            "message": "BeerBot ready"
        }

    # Iganädalane simulatsiooni samm [5]
    if not data.weeks:
        # Kui weeks puudub või on tühi (mis ei tohiks juhtuda spetsifikatsiooni järgi), 
        # tagastame vaikimisi tellimused, nagu simulaator teeks vea korral (10) [4].
        return {"orders": {"retailer": 10, "wholesaler": 10, "distributor": 10, "factory": 10}}

    last_week_data = data.weeks[-1]
    
    orders = {}
    
    # Arvutame tellimused kõigile neljale rollile detsentraliseeritult
    for role in Q_OPTIMIZED.keys():
        current_state = last_week_data.roles.get(role)
        
        if current_state:
            # Kasutame Q-mudeli loogikat tellimuse arvutamiseks
            orders[role] = calculate_order(role, current_state, data.weeks)
        else:
            # Vaikimisi väärtus, kui rolli andmed puuduvad
            orders[role] = 10 

    # Tagastab tellimused järgmiseks nädalaks [19]
    return {"orders": orders}

# Koodi käivitamiseks lokaalselt (kasutades uvicorn):
# uvicorn main:app --reload
